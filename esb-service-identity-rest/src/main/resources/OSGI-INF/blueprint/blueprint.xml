<?xml version="1.0" encoding="UTF-8"?>

<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
	xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0"
	xmlns:cxf="http://camel.apache.org/schema/blueprint/cxf" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:jpa="http://aries.apache.org/xmlns/jpa/v1.1.0"
	xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd http://aries.apache.org/xmlns/jpa/v1.1.0 http://aries.apache.org/schemas/jpa/jpa_110.xsd"
	default-activation="eager">

	<cm:property-placeholder persistent-id="se.uu.its.integration.service.cxf.receive">
		<cm:default-properties>
			<cm:property name="CXFserver" value="http://0.0.0.0:8989/" />
			<cm:property name="service" value="esb/rest" />
		</cm:default-properties>
	</cm:property-placeholder>

	<cxf:rsServer id="rsServer" address="${CXFserver}${service}"
		serviceClass="se.uu.its.integration.service.identity.rest.IdentityService"
		loggingFeatureEnabled="true" loggingSizeLimit="20" />

	<reference id="entityManagerFactory" interface="javax.persistence.EntityManagerFactory" />
	<reference id="platformTxManager" interface="org.springframework.transaction.PlatformTransactionManager" />

	<reference id="transactionManager" interface="javax.transaction.TransactionManager" />
	<reference id="recoverableTxManager" interface="org.apache.geronimo.transaction.manager.RecoverableTransactionManager" />

	<!-- Setting up the amq:// components with a configuration that points to 
		the JcaPooledConnectionFactory and the global Spring PlatformTransactiongManager. 
		Note that transacted is set to 'false' because it's the JTA TransactionManager 
		that manages the transactions and not the JMS component itself. -->
	<bean id="amq" class="org.apache.camel.component.jms.JmsComponent">
		<property name="configuration" ref="AMQConfig" />
	</bean>

	<bean id="AMQConfig" class="org.apache.camel.component.jms.JmsConfiguration">
		<property name="connectionFactory" ref="XAPooledCF" />
		<property name="transacted" value="false" />
		<property name="transactionManager" ref="platformTxManager" />
		<property name="maxConcurrentConsumers" value="1" />
		<property name="cacheLevelName" value="CACHE_NONE" />
	</bean>

	<!-- The JcaPooledConnectionFactory ensures that the JMS Sessions get enlisted 
		in the global transaction manager -->
	<bean id="XAPooledCF" class="org.apache.activemq.pool.JcaPooledConnectionFactory" init-method="start" destroy-method="stop">
		<property name="name" value="activemq.default" />
		<property name="maxConnections" value="1" />
		<property name="connectionFactory" ref="AmqXaCF" />
		<property name="transactionManager" ref="transactionManager" />
	</bean>

	<!-- Defines an ActiveMQ XA-aware ConnectionFactory -->
	<bean id="AmqXaCF" class="org.apache.activemq.ActiveMQXAConnectionFactory">
		<property name="brokerURL"
			value="failover:(tcp://localhost:61616)?jms.prefetchPolicy.all=1" />
		<property name="userName" value="smx" />
		<property name="password" value="smx" />
	</bean>

	<!-- A ResourceManager is needed for every transactional resource in order 
		to recover any outstanding transactions after a crash. It will register with 
		the Aries transaction manager, which then calls recoverResource() on the 
		transactional resource itself. -->
	<bean id="resourceManager-AMQ" class="org.apache.activemq.pool.ActiveMQResourceManager" init-method="recoverResource">
		<property name="transactionManager" ref="recoverableTxManager" />
		<!-- CF must be of type ActiveMQConnectionFactory, otherwise no recovery will occur -->
		<property name="connectionFactory" ref="AmqXaCF" />
		<property name="resourceName" value="activemq.default" />
		<property name="userName" value="smx" />
		<property name="password" value="smx" />
	</bean>

	<bean id="modelUtils" class="se.uu.its.integration.model.common.ModelUtils" />
	<bean id="esbEventLogger" class="se.uu.its.integration.esb.logger.ESBEventLogger" />
	<bean id="deadLetterErrorHandler" class="org.apache.camel.builder.DeadLetterChannelBuilder">
		<property name="deadLetterUri" value="activemq:queue:identity-event-deadletter" />
	</bean>

	<bean id="jpa" class="org.apache.camel.component.jpa.JpaComponent">
		<property name="entityManagerFactory" ref="entityManagerFactory" />
		<property name="transactionManager" ref="platformTxManager" />
	</bean>

	<bean id="PROPAGATION_REQUIRED" class="org.apache.camel.spring.spi.SpringTransactionPolicy">
		<property name="transactionManager" ref="platformTxManager" />
		<property name="propagationBehaviorName" value="PROPAGATION_REQUIRED" />
	</bean>

	<!-- 
	
	TODO: Define how to handle logs.
	
	When using a errorHandlerRef raised exception is consider handled by the transaction manager.
	This means that Camel will abort the route, but the container will commit the statements 
	handled by the transaction manager.
	
	Our dead letter handling must trigger a explicit rollback.
	
	Link:
		https://access.redhat.com/documentation/en-US/Red_Hat_JBoss_Fuse/6.0/html/EIP_Transaction_Guide/files/TxnDemarcation-ErrorHandling.html
	
	Enable logging in Karaf with:
		log:set DEBUG org.apache.activemq.transaction 
		log:set DEBUG org.springframework.transaction 	
		log:set DEBUG org.springframework.jms.connection.JmsTransactionManager 
		log:set DEBUG org.springframework.orm.jpa.JpaTransactionManager 
		log:set TRACE org.apache.geronimo.transaction.manager.WrapperNamedXAResource 
		log:set DEBUG org.apache.geronimo.transaction.log 
		log:set DEBUG org.jencks
	
	-->

	<camelContext id="IdentityService" 
<!-- 
		errorHandlerRef="deadLetterErrorHandler" 
 -->
		allowUseOriginalMessage="false"
		xmlns="http://camel.apache.org/schema/blueprint">

		<route id="IdentityServiceRoute">

			<description>
				This is the REST-endpoint for messages in the identity event domain.
			</description>

			<!-- Listen for calls from REST-binded CXF-service. -->
			<from id="Identity REST endpoint" uri="cxfrs:bean:rsServer?bindingStyle=SimpleConsumer" />

			<transacted ref="PROPAGATION_REQUIRED" />
			
			<!-- We use XML as internal integration language. -->
			<marshal id="XML translation">
				<jaxb prettyPrint="true" contextPath="se.uu.its.integration.model.events" />
			</marshal>

			<!-- Add integration event id. -->
			<to id="Event id assignment" uri="bean:modelUtils?method=addIntegrationEventIdToEvent" />

			<!-- Moved to bean cause camel cant load resource from other bundle. 
			<setHeader headerName="uid">
				<method bean="modelUtils" method="getNewEventId"/> 
			</setHeader> 
			<to uri="xslt:addIntegrationEventIdToEvent.xsl"/> 
			<to uri="xslt:se/uu/its/integration/model/transform/addIntegrationEventIdToEvent.xsl"/> -->
			
			<!-- Don't process already processed events. -->
			<filter id="Event processing filter">

				<method id="isEventProcessed" ref="esbEventLogger" method="isEventProcessed" />

 				<inOnly id="Event distribution" uri="amq:queue:identity-event-distribution" />
 				
				<!-- HÃ¤r loggar vi just nu ingenting, bara skapar responsen. -->
				<to id="Log event" uri="bean:esbEventLogger?method=logEvent" />
<!-- 
				<to id="KabooOOOOOmm" uri="bean:modelUtils?method=exceptionTrigger" />
 -->
				<unmarshal id="Object translation again">
					<jaxb prettyPrint="true" contextPath="se.uu.its.integration.model.events" />
				</unmarshal>

				<to id="Convert to UUEvent" uri="bean:modelUtils?method=convertToUUEvent" />
				<to id="Log processed events" uri="jpa:se.uu.its.integration.model.events.UUEvent?persistenceUnit=logDb" />

				<marshal id="XML translation again">
					<jaxb prettyPrint="true" contextPath="se.uu.its.integration.model.events" />
				</marshal>

				<stop id="Event processing finished" />

			</filter>

			<!-- Log not processed events. Don't passes the filter. -->
			<inOnly id="Log duplicate event" uri="activemq:queue:identity-event-duplicate" />

		</route>

	</camelContext>

</blueprint>
